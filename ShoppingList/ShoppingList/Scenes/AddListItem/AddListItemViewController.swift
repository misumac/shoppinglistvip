//
//  AddListItemViewController.swift
//  ShoppingList
//
//  Created by Mihai on 3/13/17.
//  Copyright (c) 2017 Mihai. All rights reserved.
//
//  This file was generated by the Clean Swift HELM Xcode Templates
//

import UIKit
import Toaster

protocol AddListItemViewControllerInput {
    func displayItem(viewModel: AddListItemScene.GetItemOnLoad.ViewModel)
    func displayItemSaved(viewModel: AddListItemScene.SaveItem.ViewModel)
    func displayNameSuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel)
    func displayCategorySuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel)
    func displayCategoryForItem(viewModel: AddListItemScene.GetCategory.ViewModel)
}

protocol AddListItemViewControllerOutput {
    func getItemOnLoad(request: AddListItemScene.GetItemOnLoad.Request)
    func saveItem(request: AddListItemScene.SaveItem.Request)
    func suggestNames(request: AddListItemScene.SuggestNames.Request)
    func suggestCategories(request: AddListItemScene.SuggestNames.Request)
    func getCategoryForItem(request: AddListItemScene.GetCategory.Request)
}

class AddListItemViewController: UIViewController, AddListItemViewControllerInput, UITextFieldDelegate {
    
    enum CellTypes: String {
        case nameCell = "NameCell"
        case categoryCell = "CatCell"
        case quantityCell = "QuantityCell"
        case saveCell = "SaveCell"
        case hintCell = "HintCell"
        
        func index() -> IndexPath {
            switch self {
            case .nameCell:
                return IndexPath(row: 0, section: 0)
            case .categoryCell:
                return IndexPath(row: 1, section: 0)
            case .quantityCell:
                return IndexPath(row: 2, section: 0)
            case .saveCell:
                return IndexPath(row: 0, section: 1)
            case .hintCell:
                return IndexPath(row: 0, section: 0)
            }
        }
    }
    
    var output: AddListItemViewControllerOutput!
    var router: AddListItemRouter!
    var item: AddListItemScene.ListItemVM!
    
    var editingIndex: Int? = nil
    var suggestions = [String]()
    
    @IBOutlet weak var tableView: UITableView!
    
    // MARK: Object lifecycle
    
    override func awakeFromNib() {
        super.awakeFromNib()
        AddListItemConfigurator.sharedInstance.configure(viewController: self)
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        tableView.dataSource = self
        tableView.delegate = self
        output.getItemOnLoad(request: AddListItemScene.GetItemOnLoad.Request())
    }
    
    // MARK: Event handling
    
    
    // MARK: Display logic
    func displayItem(viewModel: AddListItemScene.GetItemOnLoad.ViewModel) {
        item = viewModel.item
        navigationItem.title = viewModel.navTitle
    }
    
    func displayItemSaved(viewModel: AddListItemScene.SaveItem.ViewModel) {
        if viewModel.success {
            router.navigateToList()
        } else {
            Toast(text: viewModel.errorMessage).show()
        }
    }
    
    func displayNameSuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel) {
        debugPrint(viewModel.names)
        if viewModel.names.count > 0 {
            editingIndex = CellTypes.nameCell.index().row
            let oldSuggestions = suggestions
            suggestions = viewModel.names
            updateTable(oldSuggestions: oldSuggestions, newSuggestions: suggestions, editingIndex: editingIndex!)
        } else {
            if let oldIndex = editingIndex {
                editingIndex = nil
                let oldSuggestions = suggestions
                suggestions.removeAll()
                updateTable(oldSuggestions: oldSuggestions, newSuggestions: suggestions, editingIndex: oldIndex)
            }
        }
    }
    
    func displayCategorySuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel) {
        if viewModel.names.count > 0 {
            editingIndex = CellTypes.categoryCell.index().row
            let oldSuggestions = suggestions
            suggestions = viewModel.names
            updateTable(oldSuggestions: oldSuggestions, newSuggestions: suggestions, editingIndex: editingIndex!)
        } else {
            if let oldIndex = editingIndex {
                editingIndex = nil
                let oldSuggestions = suggestions
                suggestions.removeAll()
                updateTable(oldSuggestions: oldSuggestions, newSuggestions: suggestions, editingIndex: oldIndex)
            }
        }
    }
    
    func displayCategoryForItem(viewModel: AddListItemScene.GetCategory.ViewModel) {
        if viewModel.category.characters.count > 0 {
            item.category = viewModel.category
            tableView.reloadRows(at: [indexPath(forCellType: CellTypes.categoryCell)], with: .none)
        }
    }
    
    func updateTable(oldSuggestions: [String], newSuggestions: [String], editingIndex: Int) {
        var updates = [IndexPath]()
        var inserts = [IndexPath]()
        var deletes = [IndexPath]()
        var currentRow = editingIndex + 1
        for i in 0..<suggestions.count {
            if i < oldSuggestions.count {
                updates.append(IndexPath(row: currentRow, section: 0))
            } else {
                inserts.append(IndexPath(row: currentRow, section: 0))
            }
            currentRow = currentRow + 1
        }
        if oldSuggestions.count > suggestions.count {
            for _ in suggestions.count..<oldSuggestions.count {
                deletes.append(IndexPath(row: currentRow, section: 0))
                currentRow = currentRow + 1
            }
        }
        tableView.beginUpdates()
        if updates.count > 0 {
            tableView.reloadRows(at: updates, with: .none)
        }
        if inserts.count > 0 {
            tableView.insertRows(at: inserts, with: .none)
        }
        if deletes.count > 0 {
            tableView.deleteRows(at: deletes, with: .none)
        }
        tableView.endUpdates()
    }
    
    // MARK: Cell indexing logic
    func textField(forIndexPath indexPath: IndexPath, tag: Int) -> UITextField? {
        let cell = tableView.cellForRow(at: indexPath)
        return cell?.viewWithTag(tag) as? UITextField
    }
    
    func indexPath(forCellType cellType: CellTypes) -> IndexPath {
        var index = cellType.index()
        if index.section == 0 && editingIndex != nil {
            if index.row > editingIndex! {
                index.row = index.row + suggestions.count
            }
        }
        return index
    }
    
    func cellType(forIndex index: IndexPath) -> CellTypes {
        if index.section == 1 {
            return .saveCell
        }
        var row = index.row
        if let startIndex = editingIndex {
            if row > startIndex {
                if row <= startIndex + suggestions.count {
                    return .hintCell
                } else {
                    row = row - suggestions.count
                }
            }
        }
        switch row {
        case 0:
            return .nameCell
        case 1:
            return .categoryCell
        default:
            return .quantityCell
        }
    }
    // MARK: ViewModel updates
    
    // MARK: Cell events
    func stepperChanged(sender: UIStepper) {
        if let tf = textField(forIndexPath: indexPath(forCellType: .quantityCell), tag: 102) {
            item.quantity = Int(sender.value)
            tf.text = "\(item.quantity)"
        }
    }
    
    func textFieldValueChanged(sender: UITextField) {
        switch sender.tag {
        case 100:
            item.name = sender.text ?? ""
                output.suggestNames(request: AddListItemScene.SuggestNames.Request(filter: item.name))
        case 101:
            item.category = sender.text ?? ""
            output.suggestCategories(request: AddListItemScene.SuggestNames.Request(filter: item.category))
        case 102:
            if let text = sender.text {
                item.quantity = Int(text) ?? 1
            } else {
                item.quantity = 1
            }
            if item.quantity < 1 {
                item.quantity = 1
            }
            if let cell = tableView.cellForRow(at: indexPath(forCellType: .quantityCell)) {
                let stepper = cell.viewWithTag(103) as! UIStepper
                stepper.value = Double(item.quantity)
            }
        default:
            break
        }
    }
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        switch textField.tag {
        case 100:
            if let tf = self.textField(forIndexPath: indexPath(forCellType: .categoryCell), tag: 101) {
                tf.becomeFirstResponder()
            }
            item.name = textField.text ?? ""
        case 101:
            if let tf = self.textField(forIndexPath: indexPath(forCellType: .quantityCell), tag: 102) {
                tf.becomeFirstResponder()
            }
            item.category = textField.text ?? ""
        case 102:
            if let text = textField.text {
                item.quantity = Int(text) ?? 1
                if item.quantity < 1 {
                    item.quantity = 1
                }
                if let cell = tableView.cellForRow(at: indexPath(forCellType: .quantityCell)) {
                    let stepper = cell.viewWithTag(103) as! UIStepper
                    stepper.value = Double(item.quantity)
                }
            }
            textField.resignFirstResponder()
        default:
            break
        }
        return true
    }
    
    func textFieldDidEndEditing(_ textField: UITextField) {
        switch textField.tag {
        case 100:
            displayNameSuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel(names: [String]()))
            output.getCategoryForItem(request: AddListItemScene.GetCategory.Request(name: item.name))
        case 101:
            displayCategorySuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel(names: [String]()))
        default:
            break
        }
    }
    
    func textFieldDidBeginEditing(_ textField: UITextField) {
        switch textField.tag {
        case 100:
            output.suggestNames(request: AddListItemScene.SuggestNames.Request(filter: textField.text ?? ""))
        case 101:
            output.suggestCategories(request: AddListItemScene.SuggestNames.Request(filter: textField.text ?? ""))
        default:
            break
        }
    }
}

extension AddListItemViewController: UITableViewDataSource {
    func numberOfSections(in tableView: UITableView) -> Int {
        return 2
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if section == 0 {
            return 3 + suggestions.count
        }
        return 1
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let ctype = cellType(forIndex: indexPath)
        let cell = tableView.dequeueReusableCell(withIdentifier: ctype.rawValue, for: indexPath)
        switch ctype {
        case .nameCell:
            let textField = cell.viewWithTag(100) as! UITextField
            textField.delegate = self
            textField.text = item.name
            textField.addTarget(self, action: #selector(textFieldValueChanged(sender:)), for: UIControlEvents.editingChanged)
        case .categoryCell:
            let textField = cell.viewWithTag(101) as! UITextField
            textField.delegate = self
            textField.text = item.category
            textField.addTarget(self, action: #selector(textFieldValueChanged(sender:)), for: UIControlEvents.editingChanged)
        case .quantityCell:
            let textField = cell.viewWithTag(102) as! UITextField
            textField.text = "\(item.quantity)"
            textField.delegate = self
            textField.addTarget(self, action: #selector(textFieldValueChanged(sender:)), for: UIControlEvents.editingChanged)
            let stepper = cell.viewWithTag(103) as! UIStepper
            stepper.minimumValue = 1
            stepper.maximumValue = 100
            stepper.value = Double(item.quantity)
            stepper.stepValue = 1
            stepper.addTarget(self, action: #selector(stepperChanged(sender:)), for: UIControlEvents.valueChanged)
        case .hintCell:
            let index = indexPath.row - editingIndex! - 1
            cell.textLabel?.text = suggestions[index]
        default:
            break
        }
        return cell
    }
}

extension AddListItemViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let cell = tableView.cellForRow(at: indexPath)
        if let textField = cell?.viewWithTag(100) as? UITextField {
            tableView.deselectRow(at: indexPath, animated: false)
            textField.becomeFirstResponder()
        }
        if cell?.reuseIdentifier == CellTypes.hintCell.rawValue {
            if editingIndex == CellTypes.nameCell.index().row {
                item.name = cell?.textLabel?.text ?? ""
                displayNameSuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel(names: [String]()))
                tableView.reloadRows(at: [CellTypes.nameCell.index()], with: .none)
            } else if editingIndex == CellTypes.categoryCell.index().row {
                item.category = cell?.textLabel?.text ?? ""
                displayCategorySuggestions(viewModel: AddListItemScene.SuggestNames.ViewModel(names: [String]()))
                tableView.reloadRows(at: [CellTypes.categoryCell.index()], with: .none)
            }
        }
        if indexPath.section == 1 {
            output.saveItem(request: AddListItemScene.SaveItem.Request(item: item))
            tableView.deselectRow(at: indexPath, animated: true)
        }
    }
}

//This should be on configurator but for some reason storyboard doesn't detect ViewController's name if placed there
extension AddListItemViewController: AddListItemPresenterOutput {
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        router.passDataToNextScene(for: segue)
    }
}
